
#ifndef NODE_SQLITE3_SRC_DATABASE_H
#define NODE_SQLITE3_SRC_DATABASE_H


<<<<<<< Updated upstream
#include <assert.h>
=======
>>>>>>> Stashed changes
#include <string>
#include <queue>

#include <sqlite3.h>
<<<<<<< Updated upstream
#include <napi.h>

#include "async.h"

using namespace Napi;
=======
#include <nan.h>

#include "async.h"

using namespace v8;
>>>>>>> Stashed changes

namespace node_sqlite3 {

class Database;


<<<<<<< Updated upstream
class Database : public Napi::ObjectWrap<Database> {
public:
#if NAPI_VERSION < 6
    static Napi::FunctionReference constructor;
#endif
    static Napi::Object Init(Napi::Env env, Napi::Object exports);

    static inline bool HasInstance(Napi::Value val) {
        auto env = val.Env();
        Napi::HandleScope scope(env);
        if (!val.IsObject()) return false;
        auto obj = val.As<Napi::Object>();
#if NAPI_VERSION < 6
        return obj.InstanceOf(constructor.Value());
#else
        auto constructor =
            env.GetInstanceData<Napi::FunctionReference>();
        return obj.InstanceOf(constructor->Value());
#endif
    }

    struct Baton {
        napi_async_work request = NULL;
        Database* db;
        Napi::FunctionReference callback;
        int status;
        std::string message;

        Baton(Database* db_, Napi::Function cb_) :
                db(db_), status(SQLITE_OK) {
            db->Ref();
            if (!cb_.IsUndefined() && cb_.IsFunction()) {
                callback.Reset(cb_, 1);
            }
        }
        virtual ~Baton() {
            if (request) napi_delete_async_work(db->Env(), request);
=======
class Database : public Nan::ObjectWrap {
public:
    static Nan::Persistent<FunctionTemplate> constructor_template;
    static NAN_MODULE_INIT(Init);

    static inline bool HasInstance(Local<Value> val) {
        Nan::HandleScope scope;
        if (!val->IsObject()) return false;
        Local<Object> obj = val.As<Object>();
        return Nan::New(constructor_template)->HasInstance(obj);
    }

    struct Baton {
        uv_work_t request;
        Database* db;
        Nan::Persistent<Function> callback;
        int status;
        std::string message;

        Baton(Database* db_, Local<Function> cb_) :
                db(db_), status(SQLITE_OK) {
            db->Ref();
            request.data = this;
            callback.Reset(cb_);
        }
        virtual ~Baton() {
>>>>>>> Stashed changes
            db->Unref();
            callback.Reset();
        }
    };

    struct OpenBaton : Baton {
        std::string filename;
        int mode;
<<<<<<< Updated upstream
        OpenBaton(Database* db_, Napi::Function cb_, const char* filename_, int mode_) :
            Baton(db_, cb_), filename(filename_), mode(mode_) {}
        virtual ~OpenBaton() override = default;
=======
        OpenBaton(Database* db_, Local<Function> cb_, const char* filename_, int mode_) :
            Baton(db_, cb_), filename(filename_), mode(mode_) {}
>>>>>>> Stashed changes
    };

    struct ExecBaton : Baton {
        std::string sql;
<<<<<<< Updated upstream
        ExecBaton(Database* db_, Napi::Function cb_, const char* sql_) :
            Baton(db_, cb_), sql(sql_) {}
        virtual ~ExecBaton() override = default;
=======
        ExecBaton(Database* db_, Local<Function> cb_, const char* sql_) :
            Baton(db_, cb_), sql(sql_) {}
>>>>>>> Stashed changes
    };

    struct LoadExtensionBaton : Baton {
        std::string filename;
<<<<<<< Updated upstream
        LoadExtensionBaton(Database* db_, Napi::Function cb_, const char* filename_) :
            Baton(db_, cb_), filename(filename_) {}
        virtual ~LoadExtensionBaton() override = default;
    };

    struct LimitBaton : Baton {
        int id;
        int value;
        LimitBaton(Database* db_, Napi::Function cb_, int id_, int value_) :
            Baton(db_, cb_), id(id_), value(value_) {}
        virtual ~LimitBaton() override = default;
=======
        LoadExtensionBaton(Database* db_, Local<Function> cb_, const char* filename_) :
            Baton(db_, cb_), filename(filename_) {}
>>>>>>> Stashed changes
    };

    typedef void (*Work_Callback)(Baton* baton);

    struct Call {
        Call(Work_Callback cb_, Baton* baton_, bool exclusive_ = false) :
            callback(cb_), exclusive(exclusive_), baton(baton_) {};
        Work_Callback callback;
        bool exclusive;
        Baton* baton;
    };

    struct ProfileInfo {
        std::string sql;
        sqlite3_int64 nsecs;
    };

    struct UpdateInfo {
        int type;
        std::string database;
        std::string table;
        sqlite3_int64 rowid;
    };

    bool IsOpen() { return open; }
    bool IsLocked() { return locked; }

    typedef Async<std::string, Database> AsyncTrace;
    typedef Async<ProfileInfo, Database> AsyncProfile;
    typedef Async<UpdateInfo, Database> AsyncUpdate;

    friend class Statement;
    friend class Backup;

<<<<<<< Updated upstream
    Database(const Napi::CallbackInfo& info);
=======
protected:
    Database() : Nan::ObjectWrap(),
        _handle(NULL),
        open(false),
        closing(false),
        locked(false),
        pending(0),
        serialize(false),
        debug_trace(NULL),
        debug_profile(NULL),
        update_event(NULL) {
    }
>>>>>>> Stashed changes

    ~Database() {
        RemoveCallbacks();
        sqlite3_close(_handle);
        _handle = NULL;
        open = false;
    }

<<<<<<< Updated upstream
protected:
    WORK_DEFINITION(Open);
    WORK_DEFINITION(Exec);
    WORK_DEFINITION(Close);
    WORK_DEFINITION(LoadExtension);
=======
    static NAN_METHOD(New);
    static void Work_BeginOpen(Baton* baton);
    static void Work_Open(uv_work_t* req);
    static void Work_AfterOpen(uv_work_t* req);

    static NAN_GETTER(OpenGetter);
>>>>>>> Stashed changes

    void Schedule(Work_Callback callback, Baton* baton, bool exclusive = false);
    void Process();

<<<<<<< Updated upstream
    Napi::Value Wait(const Napi::CallbackInfo& info);
    static void Work_Wait(Baton* baton);

    Napi::Value Serialize(const Napi::CallbackInfo& info);
    Napi::Value Parallelize(const Napi::CallbackInfo& info);
    Napi::Value Configure(const Napi::CallbackInfo& info);
    Napi::Value Interrupt(const Napi::CallbackInfo& info);

    static void SetBusyTimeout(Baton* baton);
    static void SetLimit(Baton* baton);
=======
    static NAN_METHOD(Exec);
    static void Work_BeginExec(Baton* baton);
    static void Work_Exec(uv_work_t* req);
    static void Work_AfterExec(uv_work_t* req);

    static NAN_METHOD(Wait);
    static void Work_Wait(Baton* baton);

    static NAN_METHOD(Close);
    static void Work_BeginClose(Baton* baton);
    static void Work_Close(uv_work_t* req);
    static void Work_AfterClose(uv_work_t* req);

    static NAN_METHOD(LoadExtension);
    static void Work_BeginLoadExtension(Baton* baton);
    static void Work_LoadExtension(uv_work_t* req);
    static void Work_AfterLoadExtension(uv_work_t* req);

    static NAN_METHOD(Serialize);
    static NAN_METHOD(Parallelize);

    static NAN_METHOD(Configure);

    static NAN_METHOD(Interrupt);

    static void SetBusyTimeout(Baton* baton);
>>>>>>> Stashed changes

    static void RegisterTraceCallback(Baton* baton);
    static void TraceCallback(void* db, const char* sql);
    static void TraceCallback(Database* db, std::string* sql);

    static void RegisterProfileCallback(Baton* baton);
    static void ProfileCallback(void* db, const char* sql, sqlite3_uint64 nsecs);
    static void ProfileCallback(Database* db, ProfileInfo* info);

    static void RegisterUpdateCallback(Baton* baton);
    static void UpdateCallback(void* db, int type, const char* database, const char* table, sqlite3_int64 rowid);
    static void UpdateCallback(Database* db, UpdateInfo* info);

    void RemoveCallbacks();

protected:
<<<<<<< Updated upstream
    sqlite3* _handle = NULL;

    bool open = false;
    bool closing = false;
    bool locked = false;
    unsigned int pending = 0;

    bool serialize = false;

    std::queue<Call*> queue;

    AsyncTrace* debug_trace = NULL;
    AsyncProfile* debug_profile = NULL;
    AsyncUpdate* update_event = NULL;
=======
    sqlite3* _handle;

    bool open;
    bool closing;
    bool locked;
    unsigned int pending;

    bool serialize;

    std::queue<Call*> queue;

    AsyncTrace* debug_trace;
    AsyncProfile* debug_profile;
    AsyncUpdate* update_event;
>>>>>>> Stashed changes
};

}

#endif
