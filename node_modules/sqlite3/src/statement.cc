<<<<<<< Updated upstream
#include <cstring>
#include <napi.h>
#include <uv.h>
=======
#include <string.h>
#include <node.h>
#include <node_buffer.h>
#include <node_version.h>
>>>>>>> Stashed changes

#include "macros.h"
#include "database.h"
#include "statement.h"

using namespace node_sqlite3;

<<<<<<< Updated upstream
Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {
    Napi::HandleScope scope(env);

    // declare napi_default_method here as it is only available in Node v14.12.0+
    auto napi_default_method = static_cast<napi_property_attributes>(napi_writable | napi_configurable);

    auto t = DefineClass(env, "Statement", {
      InstanceMethod("bind", &Statement::Bind, napi_default_method),
      InstanceMethod("get", &Statement::Get, napi_default_method),
      InstanceMethod("run", &Statement::Run, napi_default_method),
      InstanceMethod("all", &Statement::All, napi_default_method),
      InstanceMethod("each", &Statement::Each, napi_default_method),
      InstanceMethod("reset", &Statement::Reset, napi_default_method),
      InstanceMethod("finalize", &Statement::Finalize_, napi_default_method),
    });

    exports.Set("Statement", t);
    return exports;
}

// A Napi InstanceOf for Javascript Objects "Date" and "RegExp"
bool OtherInstanceOf(Napi::Object source, const char* object_type) {
    if (strncmp(object_type, "Date", 4) == 0) {
        return source.InstanceOf(source.Env().Global().Get("Date").As<Function>());
    } else if (strncmp(object_type, "RegExp", 6) == 0) {
        return source.InstanceOf(source.Env().Global().Get("RegExp").As<Function>());
    }

    return false;
=======
Nan::Persistent<FunctionTemplate> Statement::constructor_template;

NAN_MODULE_INIT(Statement::Init) {
    Nan::HandleScope scope;

    Local<FunctionTemplate> t = Nan::New<FunctionTemplate>(New);

    t->InstanceTemplate()->SetInternalFieldCount(1);
    t->SetClassName(Nan::New("Statement").ToLocalChecked());

    Nan::SetPrototypeMethod(t, "bind", Bind);
    Nan::SetPrototypeMethod(t, "get", Get);
    Nan::SetPrototypeMethod(t, "run", Run);
    Nan::SetPrototypeMethod(t, "all", All);
    Nan::SetPrototypeMethod(t, "each", Each);
    Nan::SetPrototypeMethod(t, "reset", Reset);
    Nan::SetPrototypeMethod(t, "finalize", Finalize);

    constructor_template.Reset(t);
    Nan::Set(target, Nan::New("Statement").ToLocalChecked(),
        Nan::GetFunction(t).ToLocalChecked());
>>>>>>> Stashed changes
}

void Statement::Process() {
    if (finalized && !queue.empty()) {
        return CleanQueue();
    }

    while (prepared && !locked && !queue.empty()) {
<<<<<<< Updated upstream
        auto call = std::unique_ptr<Call>(queue.front());
        queue.pop();

        call->callback(call->baton);
=======
        Call* call = queue.front();
        queue.pop();

        call->callback(call->baton);
        delete call;
>>>>>>> Stashed changes
    }
}

void Statement::Schedule(Work_Callback callback, Baton* baton) {
    if (finalized) {
<<<<<<< Updated upstream
        queue.emplace(new Call(callback, baton));
        CleanQueue();
    }
    else if (!prepared || locked) {
        queue.emplace(new Call(callback, baton));
=======
        queue.push(new Call(callback, baton));
        CleanQueue();
    }
    else if (!prepared || locked) {
        queue.push(new Call(callback, baton));
>>>>>>> Stashed changes
    }
    else {
        callback(baton);
    }
}

template <class T> void Statement::Error(T* baton) {
<<<<<<< Updated upstream
    Statement* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    // Fail hard on logic errors.
    assert(stmt->status != 0);
    EXCEPTION(Napi::String::New(env, stmt->message.c_str()), stmt->status, exception);

    Napi::Function cb = baton->callback.Value();

    if (IS_FUNCTION(cb)) {
        Napi::Value argv[] = { exception };
        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);
    }
    else {
        Napi::Value argv[] = { Napi::String::New(env, "error"), exception };
        EMIT_EVENT(stmt->Value(), 2, argv);
=======
    Nan::HandleScope scope;

    Statement* stmt = baton->stmt;
    // Fail hard on logic errors.
    assert(stmt->status != 0);
    EXCEPTION(stmt->message, stmt->status, exception);

    Local<Function> cb = Nan::New(baton->callback);

    if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { exception };
        TRY_CATCH_CALL(stmt->handle(), cb, 1, argv);
    }
    else {
        Local<Value> argv[] = { Nan::New("error").ToLocalChecked(), exception };
        EMIT_EVENT(stmt->handle(), 2, argv);
>>>>>>> Stashed changes
    }
}

// { Database db, String sql, Array params, Function callback }
<<<<<<< Updated upstream
Statement::Statement(const Napi::CallbackInfo& info) : Napi::ObjectWrap<Statement>(info) {
    auto env = info.Env();
    int length = info.Length();

    if (length <= 0 || !Database::HasInstance(info[0])) {
        Napi::TypeError::New(env, "Database object expected").ThrowAsJavaScriptException();
        return;
    }
    else if (length <= 1 || !info[1].IsString()) {
        Napi::TypeError::New(env, "SQL query expected").ThrowAsJavaScriptException();
        return;
    }
    else if (length > 2 && !info[2].IsUndefined() && !info[2].IsFunction()) {
        Napi::TypeError::New(env, "Callback expected").ThrowAsJavaScriptException();
        return;
    }

    this->db = Napi::ObjectWrap<Database>::Unwrap(info[0].As<Napi::Object>());
    this->db->Ref();

    auto sql = info[1].As<Napi::String>();

    info.This().As<Napi::Object>().DefineProperty(Napi::PropertyDescriptor::Value("sql", sql, napi_default));


    Statement* stmt = this;

    auto* baton = new PrepareBaton(this->db, info[2].As<Napi::Function>(), stmt);
    baton->sql = std::string(sql.As<Napi::String>().Utf8Value().c_str());
    this->db->Schedule(Work_BeginPrepare, baton);
=======
NAN_METHOD(Statement::New) {
    if (!info.IsConstructCall()) {
        return Nan::ThrowTypeError("Use the new operator to create new Statement objects");
    }

    int length = info.Length();

    if (length <= 0 || !Database::HasInstance(info[0])) {
        return Nan::ThrowTypeError("Database object expected");
    }
    else if (length <= 1 || !info[1]->IsString()) {
        return Nan::ThrowTypeError("SQL query expected");
    }
    else if (length > 2 && !info[2]->IsUndefined() && !info[2]->IsFunction()) {
        return Nan::ThrowTypeError("Callback expected");
    }

    Database* db = Nan::ObjectWrap::Unwrap<Database>(info[0].As<Object>());
    Local<String> sql = Local<String>::Cast(info[1]);

    Nan::ForceSet(info.This(),Nan::New("sql").ToLocalChecked(), sql, ReadOnly);

    Statement* stmt = new Statement(db);
    stmt->Wrap(info.This());

    PrepareBaton* baton = new PrepareBaton(db, Local<Function>::Cast(info[2]), stmt);
    baton->sql = std::string(*Nan::Utf8String(sql));
    db->Schedule(Work_BeginPrepare, baton);

    info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
}

void Statement::Work_BeginPrepare(Database::Baton* baton) {
    assert(baton->db->open);
    baton->db->pending++;
<<<<<<< Updated upstream

    auto env = baton->db->Env();
    CREATE_WORK("sqlite3.Statement.Prepare", Work_Prepare, Work_AfterPrepare);
}

void Statement::Work_Prepare(napi_env e, void* data) {
=======
    int status = uv_queue_work(uv_default_loop(),
        &baton->request, Work_Prepare, (uv_after_work_cb)Work_AfterPrepare);
    assert(status == 0);
}

void Statement::Work_Prepare(uv_work_t* req) {
>>>>>>> Stashed changes
    STATEMENT_INIT(PrepareBaton);

    // In case preparing fails, we use a mutex to make sure we get the associated
    // error message.
<<<<<<< Updated upstream
    STATEMENT_MUTEX(mtx);
=======
    sqlite3_mutex* mtx = sqlite3_db_mutex(baton->db->_handle);
>>>>>>> Stashed changes
    sqlite3_mutex_enter(mtx);

    stmt->status = sqlite3_prepare_v2(
        baton->db->_handle,
        baton->sql.c_str(),
        baton->sql.size(),
        &stmt->_handle,
        NULL
    );

    if (stmt->status != SQLITE_OK) {
        stmt->message = std::string(sqlite3_errmsg(baton->db->_handle));
        stmt->_handle = NULL;
    }

    sqlite3_mutex_leave(mtx);
}

<<<<<<< Updated upstream
void Statement::Work_AfterPrepare(napi_env e, napi_status status, void* data) {
    std::unique_ptr<PrepareBaton> baton(static_cast<PrepareBaton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    if (stmt->status != SQLITE_OK) {
        Error(baton.get());
        stmt->Finalize_();
    }
    else {
        stmt->prepared = true;
        if (!baton->callback.IsEmpty() && baton->callback.Value().IsFunction()) {
            Napi::Function cb = baton->callback.Value();
            Napi::Value argv[] = { env.Null() };
            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);
=======
void Statement::Work_AfterPrepare(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(PrepareBaton);

    if (stmt->status != SQLITE_OK) {
        Error(baton);
        stmt->Finalize();
    }
    else {
        stmt->prepared = true;
        Local<Function> cb = Nan::New(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { Nan::Null() };
            TRY_CATCH_CALL(stmt->handle(), cb, 1, argv);
>>>>>>> Stashed changes
        }
    }

    STATEMENT_END();
}

<<<<<<< Updated upstream
template <class T> std::unique_ptr<Values::Field>
                   Statement::BindParameter(const Napi::Value source, T pos) {
    if (source.IsString()) {
        std::string val = source.As<Napi::String>().Utf8Value();
        return std::make_unique<Values::Text>(pos, val.length(), val.c_str());
    }
    else if (OtherInstanceOf(source.As<Object>(), "RegExp")) {
        std::string val = source.ToString().Utf8Value();
        return std::make_unique<Values::Text>(pos, val.length(), val.c_str());
    }
    else if (source.IsNumber()) {
        if (OtherIsInt(source.As<Napi::Number>())) {
            return std::make_unique<Values::Integer>(pos, source.As<Napi::Number>().Int32Value());
        } else {
            return std::make_unique<Values::Float>(pos, source.As<Napi::Number>().DoubleValue());
        }
    }
    else if (source.IsBoolean()) {
        return std::make_unique<Values::Integer>(pos, source.As<Napi::Boolean>().Value() ? 1 : 0);
    }
    else if (source.IsNull()) {
        return std::make_unique<Values::Null>(pos);
    }
    else if (source.IsBuffer()) {
        Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>();
        return std::make_unique<Values::Blob>(pos, buffer.Length(), buffer.Data());
    }
    else if (OtherInstanceOf(source.As<Object>(), "Date")) {
        return std::make_unique<Values::Float>(pos, source.ToNumber().DoubleValue());
    }
    else if (source.IsObject()) {
        auto napiVal = Napi::String::New(source.Env(), "[object Object]");
        // Check whether toString returned a value that is not undefined.
        if(napiVal.Type() == 0) {
            return NULL;
        }

        std::string val = napiVal.Utf8Value();
        return std::make_unique<Values::Text>(pos, val.length(), val.c_str());
=======
template <class T> Values::Field*
                   Statement::BindParameter(const Local<Value> source, T pos) {
    if (source->IsString() || source->IsRegExp()) {
        Nan::Utf8String val(source);
        return new Values::Text(pos, val.length(), *val);
    }
    else if (source->IsInt32()) {
        return new Values::Integer(pos, Nan::To<int32_t>(source).FromJust());
    }
    else if (source->IsNumber()) {
        return new Values::Float(pos, Nan::To<double>(source).FromJust());
    }
    else if (source->IsBoolean()) {
        return new Values::Integer(pos, Nan::To<bool>(source).FromJust() ? 1 : 0);
    }
    else if (source->IsNull()) {
        return new Values::Null(pos);
    }
    else if (Buffer::HasInstance(source)) {
        Local<Object> buffer = Nan::To<Object>(source).ToLocalChecked();
        return new Values::Blob(pos, Buffer::Length(buffer), Buffer::Data(buffer));
    }
    else if (source->IsDate()) {
        return new Values::Float(pos, Nan::To<double>(source).FromJust());
>>>>>>> Stashed changes
    }
    else {
        return NULL;
    }
}

<<<<<<< Updated upstream
template <class T> T* Statement::Bind(const Napi::CallbackInfo& info, int start, int last) {
    auto env = info.Env();
    Napi::HandleScope scope(env);

    if (last < 0) last = info.Length();
    Napi::Function callback;
    if (last > start && info[last - 1].IsFunction()) {
        callback = info[last - 1].As<Napi::Function>();
        last--;
    }

    auto *baton = new T(this, callback);

    if (start < last) {
        if (info[start].IsArray()) {
            auto array = info[start].As<Napi::Array>();
            int length = array.Length();
            // Note: bind parameters start with 1.
            for (int i = 0, pos = 1; i < length; i++, pos++) {
                baton->parameters.emplace_back(BindParameter((array).Get(i), i + 1));
            }
        }
        else if (!info[start].IsObject() || OtherInstanceOf(info[start].As<Object>(), "RegExp") 
                || OtherInstanceOf(info[start].As<Object>(), "Date") || info[start].IsBuffer()) {
            // Parameters directly in array.
            // Note: bind parameters start with 1.
            for (int i = start, pos = 1; i < last; i++, pos++) {
                baton->parameters.emplace_back(BindParameter(info[i], pos));
            }
        }
        else if (info[start].IsObject()) {
            auto object = info[start].As<Napi::Object>();
            auto array = object.GetPropertyNames();
            int length = array.Length();
            for (int i = 0; i < length; i++) {
                Napi::Value name = (array).Get(i);
                Napi::Number num = name.ToNumber();

                if (num.Int32Value() == num.DoubleValue()) {
                    baton->parameters.emplace_back(
                        BindParameter((object).Get(name), num.Int32Value()));
                }
                else {
                    baton->parameters.emplace_back(BindParameter((object).Get(name),
                        name.As<Napi::String>().Utf8Value().c_str()));
=======
template <class T> T* Statement::Bind(Nan::NAN_METHOD_ARGS_TYPE info, int start, int last) {
    Nan::HandleScope scope;

    if (last < 0) last = info.Length();
    Local<Function> callback;
    if (last > start && info[last - 1]->IsFunction()) {
        callback = Local<Function>::Cast(info[last - 1]);
        last--;
    }

    T* baton = new T(this, callback);

    if (start < last) {
        if (info[start]->IsArray()) {
            Local<Array> array = Local<Array>::Cast(info[start]);
            int length = array->Length();
            // Note: bind parameters start with 1.
            for (int i = 0, pos = 1; i < length; i++, pos++) {
                baton->parameters.push_back(BindParameter(Nan::Get(array, i).ToLocalChecked(), pos));
            }
        }
        else if (!info[start]->IsObject() || info[start]->IsRegExp() || info[start]->IsDate() || Buffer::HasInstance(info[start])) {
            // Parameters directly in array.
            // Note: bind parameters start with 1.
            for (int i = start, pos = 1; i < last; i++, pos++) {
                baton->parameters.push_back(BindParameter(info[i], pos));
            }
        }
        else if (info[start]->IsObject()) {
            Local<Object> object = Local<Object>::Cast(info[start]);
            Local<Array> array = Nan::GetPropertyNames(object).ToLocalChecked();
            int length = array->Length();
            for (int i = 0; i < length; i++) {
                Local<Value> name = Nan::Get(array, i).ToLocalChecked();

                if (name->IsInt32()) {
                    baton->parameters.push_back(
                        BindParameter(Nan::Get(object, name).ToLocalChecked(), Nan::To<int32_t>(name).FromJust()));
                }
                else {
                    baton->parameters.push_back(BindParameter(Nan::Get(object, name).ToLocalChecked(),
                        *Nan::Utf8String(name)));
>>>>>>> Stashed changes
                }
            }
        }
        else {
            return NULL;
        }
    }

    return baton;
}

bool Statement::Bind(const Parameters & parameters) {
<<<<<<< Updated upstream
    if (parameters.empty()) {
=======
    if (parameters.size() == 0) {
>>>>>>> Stashed changes
        return true;
    }

    sqlite3_reset(_handle);
    sqlite3_clear_bindings(_handle);

<<<<<<< Updated upstream
    for (auto& field : parameters) {
        if (field == NULL)
            continue;

        unsigned int pos;
        if (field->index > 0) {
            pos = field->index;
        }
        else {
            pos = sqlite3_bind_parameter_index(_handle, field->name.c_str());
        }

        switch (field->type) {
            case SQLITE_INTEGER: {
                status = sqlite3_bind_int(_handle, pos,
                    (static_cast<Values::Integer*>(field.get()))->value);
            } break;
            case SQLITE_FLOAT: {
                status = sqlite3_bind_double(_handle, pos,
                    (static_cast<Values::Float*>(field.get()))->value);
            } break;
            case SQLITE_TEXT: {
                status = sqlite3_bind_text(_handle, pos,
                    (static_cast<Values::Text*>(field.get()))->value.c_str(),
                    (static_cast<Values::Text*>(field.get()))->value.size(), SQLITE_TRANSIENT);
            } break;
            case SQLITE_BLOB: {
                status = sqlite3_bind_blob(_handle, pos,
                    (static_cast<Values::Blob*>(field.get()))->value,
                    (static_cast<Values::Blob*>(field.get()))->length, SQLITE_TRANSIENT);
            } break;
            case SQLITE_NULL: {
                status = sqlite3_bind_null(_handle, pos);
            } break;
        }
=======
    Parameters::const_iterator it = parameters.begin();
    Parameters::const_iterator end = parameters.end();

    for (; it < end; ++it) {
        Values::Field* field = *it;

        if (field != NULL) {
            int pos;
            if (field->index > 0) {
                pos = field->index;
            }
            else {
                pos = sqlite3_bind_parameter_index(_handle, field->name.c_str());
            }

            switch (field->type) {
                case SQLITE_INTEGER: {
                    status = sqlite3_bind_int(_handle, pos,
                        ((Values::Integer*)field)->value);
                } break;
                case SQLITE_FLOAT: {
                    status = sqlite3_bind_double(_handle, pos,
                        ((Values::Float*)field)->value);
                } break;
                case SQLITE_TEXT: {
                    status = sqlite3_bind_text(_handle, pos,
                        ((Values::Text*)field)->value.c_str(),
                        ((Values::Text*)field)->value.size(), SQLITE_TRANSIENT);
                } break;
                case SQLITE_BLOB: {
                    status = sqlite3_bind_blob(_handle, pos,
                        ((Values::Blob*)field)->value,
                        ((Values::Blob*)field)->length, SQLITE_TRANSIENT);
                } break;
                case SQLITE_NULL: {
                    status = sqlite3_bind_null(_handle, pos);
                } break;
            }
>>>>>>> Stashed changes

            if (status != SQLITE_OK) {
                message = std::string(sqlite3_errmsg(db->_handle));
                return false;
            }
        }
<<<<<<< Updated upstream
=======
    }
>>>>>>> Stashed changes

    return true;
}

<<<<<<< Updated upstream
Napi::Value Statement::Bind(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;

    auto baton = stmt->Bind<Baton>(info);
    if (baton == NULL) {
        Napi::TypeError::New(env, "Data type is not supported").ThrowAsJavaScriptException();
        return env.Null();
    }
    else {
        stmt->Schedule(Work_BeginBind, baton);
        return info.This();
=======
NAN_METHOD(Statement::Bind) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());

    Baton* baton = stmt->Bind<Baton>(info);
    if (baton == NULL) {
        return Nan::ThrowTypeError("Data type is not supported");
    }
    else {
        stmt->Schedule(Work_BeginBind, baton);
        info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
    }
}

void Statement::Work_BeginBind(Baton* baton) {
    STATEMENT_BEGIN(Bind);
}

<<<<<<< Updated upstream
void Statement::Work_Bind(napi_env e, void* data) {
    STATEMENT_INIT(Baton);

    STATEMENT_MUTEX(mtx);
=======
void Statement::Work_Bind(uv_work_t* req) {
    STATEMENT_INIT(Baton);

    sqlite3_mutex* mtx = sqlite3_db_mutex(stmt->db->_handle);
>>>>>>> Stashed changes
    sqlite3_mutex_enter(mtx);
    stmt->Bind(baton->parameters);
    sqlite3_mutex_leave(mtx);
}

<<<<<<< Updated upstream
void Statement::Work_AfterBind(napi_env e, napi_status status, void* data) {
    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    if (stmt->status != SQLITE_OK) {
        Error(baton.get());
    }
    else {
        // Fire callbacks.
        Napi::Function cb = baton->callback.Value();
        if (IS_FUNCTION(cb)) {
            Napi::Value argv[] = { env.Null() };
            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);
=======
void Statement::Work_AfterBind(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(Baton);

    if (stmt->status != SQLITE_OK) {
        Error(baton);
    }
    else {
        // Fire callbacks.
        Local<Function> cb = Nan::New(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { Nan::Null() };
            TRY_CATCH_CALL(stmt->handle(), cb, 1, argv);
>>>>>>> Stashed changes
        }
    }

    STATEMENT_END();
}



<<<<<<< Updated upstream
Napi::Value Statement::Get(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;

    Baton* baton = stmt->Bind<RowBaton>(info);
    if (baton == NULL) {
        Napi::Error::New(env, "Data type is not supported").ThrowAsJavaScriptException();
        return env.Null();
    }
    else {
        stmt->Schedule(Work_BeginGet, baton);
        return info.This();
=======
NAN_METHOD(Statement::Get) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());

    Baton* baton = stmt->Bind<RowBaton>(info);
    if (baton == NULL) {
        return Nan::ThrowError("Data type is not supported");
    }
    else {
        stmt->Schedule(Work_BeginGet, baton);
        info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
    }
}

void Statement::Work_BeginGet(Baton* baton) {
    STATEMENT_BEGIN(Get);
}

<<<<<<< Updated upstream
void Statement::Work_Get(napi_env e, void* data) {
    STATEMENT_INIT(RowBaton);

    if (stmt->status != SQLITE_DONE || baton->parameters.size()) {
        STATEMENT_MUTEX(mtx);
=======
void Statement::Work_Get(uv_work_t* req) {
    STATEMENT_INIT(RowBaton);

    if (stmt->status != SQLITE_DONE || baton->parameters.size()) {
        sqlite3_mutex* mtx = sqlite3_db_mutex(stmt->db->_handle);
>>>>>>> Stashed changes
        sqlite3_mutex_enter(mtx);

        if (stmt->Bind(baton->parameters)) {
            stmt->status = sqlite3_step(stmt->_handle);

            if (!(stmt->status == SQLITE_ROW || stmt->status == SQLITE_DONE)) {
                stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));
            }
        }

        sqlite3_mutex_leave(mtx);

        if (stmt->status == SQLITE_ROW) {
            // Acquire one result row before returning.
            GetRow(&baton->row, stmt->_handle);
        }
    }
}

<<<<<<< Updated upstream
void Statement::Work_AfterGet(napi_env e, napi_status status, void* data) {
    std::unique_ptr<RowBaton> baton(static_cast<RowBaton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {
        Error(baton.get());
    }
    else {
        // Fire callbacks.
        Napi::Function cb = baton->callback.Value();
        if (IS_FUNCTION(cb)) {
            if (stmt->status == SQLITE_ROW) {
                // Create the result array from the data we acquired.
                Napi::Value argv[] = { env.Null(), RowToJS(env, &baton->row) };
                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);
            }
            else {
                Napi::Value argv[] = { env.Null() };
                TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);
=======
void Statement::Work_AfterGet(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(RowBaton);

    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {
        Error(baton);
    }
    else {
        // Fire callbacks.
        Local<Function> cb = Nan::New(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            if (stmt->status == SQLITE_ROW) {
                // Create the result array from the data we acquired.
                Local<Value> argv[] = { Nan::Null(), RowToJS(&baton->row) };
                TRY_CATCH_CALL(stmt->handle(), cb, 2, argv);
            }
            else {
                Local<Value> argv[] = { Nan::Null() };
                TRY_CATCH_CALL(stmt->handle(), cb, 1, argv);
>>>>>>> Stashed changes
            }
        }
    }

    STATEMENT_END();
}

<<<<<<< Updated upstream
Napi::Value Statement::Run(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;

    Baton* baton = stmt->Bind<RunBaton>(info);
    if (baton == NULL) {
        Napi::Error::New(env, "Data type is not supported").ThrowAsJavaScriptException();
        return env.Null();
    }
    else {
        stmt->Schedule(Work_BeginRun, baton);
        return info.This();
=======
NAN_METHOD(Statement::Run) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());

    Baton* baton = stmt->Bind<RunBaton>(info);
    if (baton == NULL) {
        return Nan::ThrowError("Data type is not supported");
    }
    else {
        stmt->Schedule(Work_BeginRun, baton);
        info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
    }
}

void Statement::Work_BeginRun(Baton* baton) {
    STATEMENT_BEGIN(Run);
}

<<<<<<< Updated upstream
void Statement::Work_Run(napi_env e, void* data) {
    STATEMENT_INIT(RunBaton);

    STATEMENT_MUTEX(mtx);
=======
void Statement::Work_Run(uv_work_t* req) {
    STATEMENT_INIT(RunBaton);

    sqlite3_mutex* mtx = sqlite3_db_mutex(stmt->db->_handle);
>>>>>>> Stashed changes
    sqlite3_mutex_enter(mtx);

    // Make sure that we also reset when there are no parameters.
    if (!baton->parameters.size()) {
        sqlite3_reset(stmt->_handle);
    }

    if (stmt->Bind(baton->parameters)) {
        stmt->status = sqlite3_step(stmt->_handle);

        if (!(stmt->status == SQLITE_ROW || stmt->status == SQLITE_DONE)) {
            stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));
        }
        else {
            baton->inserted_id = sqlite3_last_insert_rowid(stmt->db->_handle);
            baton->changes = sqlite3_changes(stmt->db->_handle);
        }
    }

    sqlite3_mutex_leave(mtx);
}

<<<<<<< Updated upstream
void Statement::Work_AfterRun(napi_env e, napi_status status, void* data) {
    std::unique_ptr<RunBaton> baton(static_cast<RunBaton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {
        Error(baton.get());
    }
    else {
        // Fire callbacks.
        Napi::Function cb = baton->callback.Value();
        if (IS_FUNCTION(cb)) {
            (stmt->Value()).Set(Napi::String::New(env, "lastID"), Napi::Number::New(env, baton->inserted_id));
            (stmt->Value()).Set( Napi::String::New(env, "changes"), Napi::Number::New(env, baton->changes));

            Napi::Value argv[] = { env.Null() };
            TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);
=======
void Statement::Work_AfterRun(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(RunBaton);

    if (stmt->status != SQLITE_ROW && stmt->status != SQLITE_DONE) {
        Error(baton);
    }
    else {
        // Fire callbacks.
        Local<Function> cb = Nan::New(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            Nan::Set(stmt->handle(), Nan::New("lastID").ToLocalChecked(), Nan::New<Number>(baton->inserted_id));
            Nan::Set(stmt->handle(), Nan::New("changes").ToLocalChecked(), Nan::New(baton->changes));

            Local<Value> argv[] = { Nan::Null() };
            TRY_CATCH_CALL(stmt->handle(), cb, 1, argv);
>>>>>>> Stashed changes
        }
    }

    STATEMENT_END();
}

<<<<<<< Updated upstream
Napi::Value Statement::All(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;

    Baton* baton = stmt->Bind<RowsBaton>(info);
    if (baton == NULL) {
        Napi::Error::New(env, "Data type is not supported").ThrowAsJavaScriptException();
        return env.Null();
    }
    else {
        stmt->Schedule(Work_BeginAll, baton);
        return info.This();
=======
NAN_METHOD(Statement::All) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());

    Baton* baton = stmt->Bind<RowsBaton>(info);
    if (baton == NULL) {
        return Nan::ThrowError("Data type is not supported");
    }
    else {
        stmt->Schedule(Work_BeginAll, baton);
        info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
    }
}

void Statement::Work_BeginAll(Baton* baton) {
    STATEMENT_BEGIN(All);
}

<<<<<<< Updated upstream
void Statement::Work_All(napi_env e, void* data) {
    STATEMENT_INIT(RowsBaton);

    STATEMENT_MUTEX(mtx);
=======
void Statement::Work_All(uv_work_t* req) {
    STATEMENT_INIT(RowsBaton);

    sqlite3_mutex* mtx = sqlite3_db_mutex(stmt->db->_handle);
>>>>>>> Stashed changes
    sqlite3_mutex_enter(mtx);

    // Make sure that we also reset when there are no parameters.
    if (!baton->parameters.size()) {
        sqlite3_reset(stmt->_handle);
    }

    if (stmt->Bind(baton->parameters)) {
        while ((stmt->status = sqlite3_step(stmt->_handle)) == SQLITE_ROW) {
<<<<<<< Updated upstream
            auto row = std::make_unique<Row>();
            GetRow(row.get(), stmt->_handle);
            baton->rows.emplace_back(std::move(row));
=======
            Row* row = new Row();
            GetRow(row, stmt->_handle);
            baton->rows.push_back(row);
>>>>>>> Stashed changes
        }

        if (stmt->status != SQLITE_DONE) {
            stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));
        }
    }

    sqlite3_mutex_leave(mtx);
}

<<<<<<< Updated upstream
void Statement::Work_AfterAll(napi_env e, napi_status status, void* data) {
    std::unique_ptr<RowsBaton> baton(static_cast<RowsBaton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    if (stmt->status != SQLITE_DONE) {
        Error(baton.get());
    }
    else {
        // Fire callbacks.
        Napi::Function cb = baton->callback.Value();
        if (IS_FUNCTION(cb)) {
            if (baton->rows.size()) {
                // Create the result array from the data we acquired.
                Napi::Array result(Napi::Array::New(env, baton->rows.size()));
                auto it = static_cast<Rows::const_iterator>(baton->rows.begin());
                decltype(it) end = baton->rows.end();
                for (int i = 0; it < end; ++it, i++) {
                    (result).Set(i, RowToJS(env, it->get()));
                }

                Napi::Value argv[] = { env.Null(), result };
                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);
            }
            else {
                // There were no result rows.
                Napi::Value argv[] = {
                    env.Null(),
                    Napi::Array::New(env, 0)
                };
                TRY_CATCH_CALL(stmt->Value(), cb, 2, argv);
=======
void Statement::Work_AfterAll(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(RowsBaton);

    if (stmt->status != SQLITE_DONE) {
        Error(baton);
    }
    else {
        // Fire callbacks.
        Local<Function> cb = Nan::New(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            if (baton->rows.size()) {
                // Create the result array from the data we acquired.
                Local<Array> result(Nan::New<Array>(baton->rows.size()));
                Rows::const_iterator it = baton->rows.begin();
                Rows::const_iterator end = baton->rows.end();
                for (int i = 0; it < end; ++it, i++) {
                    Nan::Set(result, i, RowToJS(*it));
                    delete *it;
                }

                Local<Value> argv[] = { Nan::Null(), result };
                TRY_CATCH_CALL(stmt->handle(), cb, 2, argv);
            }
            else {
                // There were no result rows.
                Local<Value> argv[] = {
                    Nan::Null(),
                    Nan::New<Array>(0)
                };
                TRY_CATCH_CALL(stmt->handle(), cb, 2, argv);
>>>>>>> Stashed changes
            }
        }
    }

    STATEMENT_END();
}

<<<<<<< Updated upstream
Napi::Value Statement::Each(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;

    int last = info.Length();

    Napi::Function completed;
    if (last >= 2 && info[last - 1].IsFunction() && info[last - 2].IsFunction()) {
        completed = info[--last].As<Napi::Function>();
    }

    auto baton = stmt->Bind<EachBaton>(info, 0, last);
    if (baton == NULL) {
        Napi::Error::New(env, "Data type is not supported").ThrowAsJavaScriptException();
        return env.Null();
    }
    else {
        baton->completed.Reset(completed, 1);
        stmt->Schedule(Work_BeginEach, baton);
        return info.This();
=======
NAN_METHOD(Statement::Each) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());

    int last = info.Length();

    Local<Function> completed;
    if (last >= 2 && info[last - 1]->IsFunction() && info[last - 2]->IsFunction()) {
        completed = Local<Function>::Cast(info[--last]);
    }

    EachBaton* baton = stmt->Bind<EachBaton>(info, 0, last);
    if (baton == NULL) {
        return Nan::ThrowError("Data type is not supported");
    }
    else {
        baton->completed.Reset(completed);
        stmt->Schedule(Work_BeginEach, baton);
        info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
    }
}

void Statement::Work_BeginEach(Baton* baton) {
    // Only create the Async object when we're actually going into
    // the event loop. This prevents dangling events.
<<<<<<< Updated upstream
    auto* each_baton = static_cast<EachBaton*>(baton);
    each_baton->async = new Async(each_baton->stmt, reinterpret_cast<uv_async_cb>(AsyncEach));
    each_baton->async->item_cb.Reset(each_baton->callback.Value(), 1);
    each_baton->async->completed_cb.Reset(each_baton->completed.Value(), 1);
=======
    EachBaton* each_baton = static_cast<EachBaton*>(baton);
    each_baton->async = new Async(each_baton->stmt, reinterpret_cast<uv_async_cb>(AsyncEach));
    each_baton->async->item_cb.Reset(each_baton->callback);
    each_baton->async->completed_cb.Reset(each_baton->completed);
>>>>>>> Stashed changes

    STATEMENT_BEGIN(Each);
}

<<<<<<< Updated upstream
void Statement::Work_Each(napi_env e, void* data) {
    STATEMENT_INIT(EachBaton);

    auto* async = baton->async;

    STATEMENT_MUTEX(mtx);
=======
void Statement::Work_Each(uv_work_t* req) {
    STATEMENT_INIT(EachBaton);

    Async* async = baton->async;

    sqlite3_mutex* mtx = sqlite3_db_mutex(stmt->db->_handle);

    int retrieved = 0;
>>>>>>> Stashed changes

    // Make sure that we also reset when there are no parameters.
    if (!baton->parameters.size()) {
        sqlite3_reset(stmt->_handle);
    }

    if (stmt->Bind(baton->parameters)) {
        while (true) {
            sqlite3_mutex_enter(mtx);
            stmt->status = sqlite3_step(stmt->_handle);
            if (stmt->status == SQLITE_ROW) {
                sqlite3_mutex_leave(mtx);
<<<<<<< Updated upstream
                auto row = std::make_unique<Row>();
                GetRow(row.get(), stmt->_handle);
                NODE_SQLITE3_MUTEX_LOCK(&async->mutex)
                async->data.emplace_back(std::move(row));
=======
                Row* row = new Row();
                GetRow(row, stmt->_handle);
                NODE_SQLITE3_MUTEX_LOCK(&async->mutex)
                async->data.push_back(row);
                retrieved++;
>>>>>>> Stashed changes
                NODE_SQLITE3_MUTEX_UNLOCK(&async->mutex)

                uv_async_send(&async->watcher);
            }
            else {
                if (stmt->status != SQLITE_DONE) {
                    stmt->message = std::string(sqlite3_errmsg(stmt->db->_handle));
                }
                sqlite3_mutex_leave(mtx);
                break;
            }
        }
    }

    async->completed = true;
    uv_async_send(&async->watcher);
}

void Statement::CloseCallback(uv_handle_t* handle) {
    assert(handle != NULL);
    assert(handle->data != NULL);
<<<<<<< Updated upstream
    auto* async = static_cast<Async*>(handle->data);
    delete async;
}

void Statement::AsyncEach(uv_async_t* handle) {
    auto* async = static_cast<Async*>(handle->data);

    auto env = async->stmt->Env();
    Napi::HandleScope scope(env);
=======
    Async* async = static_cast<Async*>(handle->data);
    delete async;
}

void Statement::AsyncEach(uv_async_t* handle, int status) {
    Nan::HandleScope scope;

    Async* async = static_cast<Async*>(handle->data);
>>>>>>> Stashed changes

    while (true) {
        // Get the contents out of the data cache for us to process in the JS callback.
        Rows rows;
        NODE_SQLITE3_MUTEX_LOCK(&async->mutex)
        rows.swap(async->data);
        NODE_SQLITE3_MUTEX_UNLOCK(&async->mutex)

        if (rows.empty()) {
            break;
        }

<<<<<<< Updated upstream
        Napi::Function cb = async->item_cb.Value();
        if (IS_FUNCTION(cb)) {
            Napi::Value argv[2];
            argv[0] = env.Null();

            for(auto& row : rows) {
                argv[1] = RowToJS(env,row.get());
                async->retrieved++;
                TRY_CATCH_CALL(async->stmt->Value(), cb, 2, argv);
=======
        Local<Function> cb = Nan::New(async->item_cb);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[2];
            argv[0] = Nan::Null();

            Rows::const_iterator it = rows.begin();
            Rows::const_iterator end = rows.end();
            for (int i = 0; it < end; ++it, i++) {
                argv[1] = RowToJS(*it);
                async->retrieved++;
                TRY_CATCH_CALL(async->stmt->handle(), cb, 2, argv);
                delete *it;
>>>>>>> Stashed changes
            }
        }
    }

<<<<<<< Updated upstream
    Napi::Function cb = async->completed_cb.Value();
    if (async->completed) {
        if (!cb.IsEmpty() &&
                cb.IsFunction()) {
            Napi::Value argv[] = {
                env.Null(),
                Napi::Number::New(env, async->retrieved)
            };
            TRY_CATCH_CALL(async->stmt->Value(), cb, 2, argv);
=======
    Local<Function> cb = Nan::New(async->completed_cb);
    if (async->completed) {
        if (!cb.IsEmpty() &&
                cb->IsFunction()) {
            Local<Value> argv[] = {
                Nan::Null(),
                Nan::New(async->retrieved)
            };
            TRY_CATCH_CALL(async->stmt->handle(), cb, 2, argv);
>>>>>>> Stashed changes
        }
        uv_close(reinterpret_cast<uv_handle_t*>(handle), CloseCallback);
    }
}

<<<<<<< Updated upstream
void Statement::Work_AfterEach(napi_env e, napi_status status, void* data) {
    std::unique_ptr<EachBaton> baton(static_cast<EachBaton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    if (stmt->status != SQLITE_DONE) {
        Error(baton.get());
=======
void Statement::Work_AfterEach(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(EachBaton);

    if (stmt->status != SQLITE_DONE) {
        Error(baton);
>>>>>>> Stashed changes
    }

    STATEMENT_END();
}

<<<<<<< Updated upstream
Napi::Value Statement::Reset(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;

    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    auto* baton = new Baton(stmt, callback);
    stmt->Schedule(Work_BeginReset, baton);

    return info.This();
=======
NAN_METHOD(Statement::Reset) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());

    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    Baton* baton = new Baton(stmt, callback);
    stmt->Schedule(Work_BeginReset, baton);

    info.GetReturnValue().Set(info.This());
>>>>>>> Stashed changes
}

void Statement::Work_BeginReset(Baton* baton) {
    STATEMENT_BEGIN(Reset);
}

<<<<<<< Updated upstream
void Statement::Work_Reset(napi_env e, void* data) {
=======
void Statement::Work_Reset(uv_work_t* req) {
>>>>>>> Stashed changes
    STATEMENT_INIT(Baton);

    sqlite3_reset(stmt->_handle);
    stmt->status = SQLITE_OK;
}

<<<<<<< Updated upstream
void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {
    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));
    auto* stmt = baton->stmt;

    auto env = stmt->Env();
    Napi::HandleScope scope(env);

    // Fire callbacks.
    Napi::Function cb = baton->callback.Value();
    if (IS_FUNCTION(cb)) {
        Napi::Value argv[] = { env.Null() };
        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);
=======
void Statement::Work_AfterReset(uv_work_t* req) {
    Nan::HandleScope scope;

    STATEMENT_INIT(Baton);

    // Fire callbacks.
    Local<Function> cb = Nan::New(baton->callback);
    if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { Nan::Null() };
        TRY_CATCH_CALL(stmt->handle(), cb, 1, argv);
>>>>>>> Stashed changes
    }

    STATEMENT_END();
}

<<<<<<< Updated upstream
Napi::Value Statement::RowToJS(Napi::Env env, Row* row) {
    Napi::EscapableHandleScope scope(env);

    auto result = Napi::Object::New(env);

    for (auto& field : *row) {

        Napi::Value value;

        switch (field->type) {
            case SQLITE_INTEGER: {
                value = Napi::Number::New(env, (static_cast<Values::Integer*>(field.get()))->value);
            } break;
            case SQLITE_FLOAT: {
                value = Napi::Number::New(env, (static_cast<Values::Float*>(field.get()))->value);
            } break;
            case SQLITE_TEXT: {
                value = Napi::String::New(env, (static_cast<Values::Text*>(field.get()))->value.c_str(), 
                                               (static_cast<Values::Text*>(field.get()))->value.size());
            } break;
            case SQLITE_BLOB: {
                value = Napi::Buffer<char>::Copy(env, (static_cast<Values::Blob*>(field.get()))->value, 
                                                      (static_cast<Values::Blob*>(field.get()))->length);
            } break;
            case SQLITE_NULL: {
                value = env.Null();
            } break;
        }

        result.Set(field->name, value);
=======
Local<Object> Statement::RowToJS(Row* row) {
    Nan::EscapableHandleScope scope;

    Local<Object> result = Nan::New<Object>();

    Row::const_iterator it = row->begin();
    Row::const_iterator end = row->end();
    for (int i = 0; it < end; ++it, i++) {
        Values::Field* field = *it;

        Local<Value> value;

        switch (field->type) {
            case SQLITE_INTEGER: {
                value = Nan::New<Number>(((Values::Integer*)field)->value);
            } break;
            case SQLITE_FLOAT: {
                value = Nan::New<Number>(((Values::Float*)field)->value);
            } break;
            case SQLITE_TEXT: {
                value = Nan::New<String>(((Values::Text*)field)->value.c_str(), ((Values::Text*)field)->value.size()).ToLocalChecked();
            } break;
            case SQLITE_BLOB: {
                value = Nan::CopyBuffer(((Values::Blob*)field)->value, ((Values::Blob*)field)->length).ToLocalChecked();
            } break;
            case SQLITE_NULL: {
                value = Nan::Null();
            } break;
        }

        Nan::Set(result, Nan::New(field->name.c_str()).ToLocalChecked(), value);

        DELETE_FIELD(field);
>>>>>>> Stashed changes
    }

    return scope.Escape(result);
}

void Statement::GetRow(Row* row, sqlite3_stmt* stmt) {
<<<<<<< Updated upstream
    int cols = sqlite3_column_count(stmt);

    for (int i = 0; i < cols; i++) {
        int type = sqlite3_column_type(stmt, i);
        const char* name = sqlite3_column_name(stmt, i);
        if (name == NULL) {
            assert(false);
        }

        switch (type) {
            case SQLITE_INTEGER: {
                row->emplace_back(std::make_unique<Values::Integer>(name, sqlite3_column_int64(stmt, i)));
            }   break;
            case SQLITE_FLOAT: {
                row->emplace_back(std::make_unique<Values::Float>(name, sqlite3_column_double(stmt, i)));
=======
    int rows = sqlite3_column_count(stmt);

    for (int i = 0; i < rows; i++) {
        int type = sqlite3_column_type(stmt, i);
        const char* name = sqlite3_column_name(stmt, i);
        switch (type) {
            case SQLITE_INTEGER: {
                row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));
            }   break;
            case SQLITE_FLOAT: {
                row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));
>>>>>>> Stashed changes
            }   break;
            case SQLITE_TEXT: {
                const char* text = (const char*)sqlite3_column_text(stmt, i);
                int length = sqlite3_column_bytes(stmt, i);
<<<<<<< Updated upstream
                row->emplace_back(std::make_unique<Values::Text>(name, length, text));
=======
                row->push_back(new Values::Text(name, length, text));
>>>>>>> Stashed changes
            } break;
            case SQLITE_BLOB: {
                const void* blob = sqlite3_column_blob(stmt, i);
                int length = sqlite3_column_bytes(stmt, i);
<<<<<<< Updated upstream
                row->emplace_back(std::make_unique<Values::Blob>(name, length, blob));
            }   break;
            case SQLITE_NULL: {
                row->emplace_back(std::make_unique<Values::Null>(name));
=======
                row->push_back(new Values::Blob(name, length, blob));
            }   break;
            case SQLITE_NULL: {
                row->push_back(new Values::Null(name));
>>>>>>> Stashed changes
            }   break;
            default:
                assert(false);
        }
    }
}

<<<<<<< Updated upstream
Napi::Value Statement::Finalize_(const Napi::CallbackInfo& info) {
    auto env = info.Env();
    Statement* stmt = this;
    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    auto *baton = new Baton(stmt, callback);
    stmt->Schedule(Finalize_, baton);

    return stmt->db->Value();
}

void Statement::Finalize_(Baton* b) {
    auto baton = std::unique_ptr<Baton>(b);
    auto env = baton->stmt->Env();
    Napi::HandleScope scope(env);

    baton->stmt->Finalize_();

    // Fire callback in case there was one.
    Napi::Function cb = baton->callback.Value();
    if (IS_FUNCTION(cb)) {
        TRY_CATCH_CALL(baton->stmt->Value(), cb, 0, NULL);
    }
}

void Statement::Finalize_() {
=======
NAN_METHOD(Statement::Finalize) {
    Statement* stmt = Nan::ObjectWrap::Unwrap<Statement>(info.This());
    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    Baton* baton = new Baton(stmt, callback);
    stmt->Schedule(Finalize, baton);

    info.GetReturnValue().Set(stmt->db->handle());
}

void Statement::Finalize(Baton* baton) {
    Nan::HandleScope scope;

    baton->stmt->Finalize();

    // Fire callback in case there was one.
    Local<Function> cb = Nan::New(baton->callback);
    if (!cb.IsEmpty() && cb->IsFunction()) {
        TRY_CATCH_CALL(baton->stmt->handle(), cb, 0, NULL);
    }

    delete baton;
}

void Statement::Finalize() {
>>>>>>> Stashed changes
    assert(!finalized);
    finalized = true;
    CleanQueue();
    // Finalize returns the status code of the last operation. We already fired
    // error events in case those failed.
    sqlite3_finalize(_handle);
    _handle = NULL;
    db->Unref();
}

void Statement::CleanQueue() {
<<<<<<< Updated upstream
    auto env = this->Env();
    Napi::HandleScope scope(env);
=======
    Nan::HandleScope scope;
>>>>>>> Stashed changes

    if (prepared && !queue.empty()) {
        // This statement has already been prepared and is now finalized.
        // Fire error for all remaining items in the queue.
<<<<<<< Updated upstream
        EXCEPTION(Napi::String::New(env, "Statement is already finalized"), SQLITE_MISUSE, exception);
        Napi::Value argv[] = { exception };
=======
        EXCEPTION("Statement is already finalized", SQLITE_MISUSE, exception);
        Local<Value> argv[] = { exception };
>>>>>>> Stashed changes
        bool called = false;

        // Clear out the queue so that this object can get GC'ed.
        while (!queue.empty()) {
<<<<<<< Updated upstream
            auto call = std::unique_ptr<Call>(queue.front());
            queue.pop();

            auto baton = std::unique_ptr<Baton>(call->baton);
            Napi::Function cb = baton->callback.Value();

            if (prepared && !cb.IsEmpty() &&
                cb.IsFunction()) {
                TRY_CATCH_CALL(Value(), cb, 1, argv);
                called = true;
            }
=======
            Call* call = queue.front();
            queue.pop();

            Local<Function> cb = Nan::New(call->baton->callback);

            if (prepared && !cb.IsEmpty() &&
                cb->IsFunction()) {
                TRY_CATCH_CALL(handle(), cb, 1, argv);
                called = true;
            }

            // We don't call the actual callback, so we have to make sure that
            // the baton gets destroyed.
            delete call->baton;
            delete call;
>>>>>>> Stashed changes
        }

        // When we couldn't call a callback function, emit an error on the
        // Statement object.
        if (!called) {
<<<<<<< Updated upstream
            Napi::Value info[] = { Napi::String::New(env, "error"), exception };
            EMIT_EVENT(Value(), 2, info);
=======
            Local<Value> info[] = { Nan::New("error").ToLocalChecked(), exception };
            EMIT_EVENT(handle(), 2, info);
>>>>>>> Stashed changes
        }
    }
    else while (!queue.empty()) {
        // Just delete all items in the queue; we already fired an event when
        // preparing the statement failed.
<<<<<<< Updated upstream
        auto call = std::unique_ptr<Call>(queue.front());
        queue.pop();
        // We don't call the actual callback, so we have to make sure that
        // the baton gets destroyed.
        delete call->baton;
=======
        Call* call = queue.front();
        queue.pop();

        // We don't call the actual callback, so we have to make sure that
        // the baton gets destroyed.
        delete call->baton;
        delete call;
>>>>>>> Stashed changes
    }
}
